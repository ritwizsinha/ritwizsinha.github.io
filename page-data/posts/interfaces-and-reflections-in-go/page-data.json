{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/interfaces-and-reflections-in-go","result":{"data":{"markdownRemark":{"id":"485d5085-090e-5bfb-be9c-385a788625d0","html":"<p>Recently I was reading about the laws of reflection in Go using this <a href=\"https://go.dev/blog/laws-of-reflection\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">article</a> and after rereading this post 2-3 times I realized there was no need to make it so complex and draw meaningless analogies with the <a href=\"https://www.physicsclassroom.com/class/refln/Lesson-1/The-Law-of-Reflection#:~:text=The%20law%20of%20reflection%20states,to%20the%20angle%20of%20reflection.\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">laws of reflection in physics</a>. Understanding about reflection also lead me to read more about interfaces in Go. In this post I aim to explain this topic succintly</p>\n<h2 id=\"introduction\" style=\"position:relative;\"><a href=\"#introduction\" aria-label=\"introduction permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction</h2>\n<p>An interface is a concept of explicity stating the group of operations which can be performed on a particular type of data. An interface allows one body to interact with another without knowing any detail about how the latter works. One simple example of an interface is the remote which is used to control the television. The remote acts as an interface between the TV and you providing the user the ability to control the TV without knowing the gruesome details of radio communication. Many languages support interfaces or interface derivatives.</p>\n<h2 id=\"the-duality-of-interfaces\" style=\"position:relative;\"><a href=\"#the-duality-of-interfaces\" aria-label=\"the duality of interfaces permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The duality of interfaces</h2>\n<p>Interfaces in Go are static and behave dynamically when the need be. Internally the interface values are represented as a two word pair having a pointer to the data and another to information of the type stored in the interface. For more information read this <a href=\"https://research.swtch.com/interfaces\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">article</a> which goes in depth of internals of interfaces. In short it may seem that interfaces behave dynamically but that is only on the surface, a variable of type some interface always has the same static type and even though the value stored in the interface changes, the value always satisfy the interface. Interfaces in Go can be considered a data structure type for storing of types and data. Data Types like uint32 store 32 bit integer and and interface of the form,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">type ReaderCloser interface {\n    Read(p []byte) (n int, err error)\n    Close()\n}</code></pre></div>\n<p>will always store any data which implement these functions.</p>\n<h2 id=\"reflection\" style=\"position:relative;\"><a href=\"#reflection\" aria-label=\"reflection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reflection</h2>\n<p>The Reflect Package helps us to extract the value and type pair from an interface explicitly. The reflect has methods <i>TypeOf</i> and <i>ValueOf</i> to extract the Type and Value from an interface. The package has two basic types <i>Type</i> and <i>Value</i> and allows us to perform a variety of operations on the items, all of which are explained <a href=\"https://pkg.go.dev/reflect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a></p>","fields":{"slug":"/posts/interfaces-and-reflections-in-go","tagSlugs":["/tag/go/","/tag/languagedesign/","/tag/interfaces/","/tag/reflections/"]},"frontmatter":{"date":"2022-01-31T11:52:11.792Z","description":"This post talks about how interfaces work internally in Go and simplifies the concept of Reflection which is needlessly compicated with over the top analogies in the official Go Blog Post on the Laws of Reflection","tags":["go","languagedesign","interfaces","reflections"],"title":"Interfaces and Reflections In Go","socialImage":{"publicURL":"/static/8aa08b6a0b142aad9e8a774a632d4935/gfs.png"}}}},"pageContext":{"slug":"/posts/interfaces-and-reflections-in-go"}},"staticQueryHashes":["251939775","3233555260","401334301"]}